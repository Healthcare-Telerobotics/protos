// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: catheter_recording_service.proto

#ifndef PROTOBUF_INCLUDED_catheter_5frecording_5fservice_2eproto
#define PROTOBUF_INCLUDED_catheter_5frecording_5fservice_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_catheter_5frecording_5fservice_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_catheter_5frecording_5fservice_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_catheter_5frecording_5fservice_2eproto();
namespace github {
namespace com {
namespace pyrus {
namespace platform {
namespace protos {
class AckReceivedCatheterRequest;
class AckReceivedCatheterRequestDefaultTypeInternal;
extern AckReceivedCatheterRequestDefaultTypeInternal _AckReceivedCatheterRequest_default_instance_;
class AckReceivedCatheterResponse;
class AckReceivedCatheterResponseDefaultTypeInternal;
extern AckReceivedCatheterResponseDefaultTypeInternal _AckReceivedCatheterResponse_default_instance_;
class ListCatheterRequest;
class ListCatheterRequestDefaultTypeInternal;
extern ListCatheterRequestDefaultTypeInternal _ListCatheterRequest_default_instance_;
class ListCatheterResponse;
class ListCatheterResponseDefaultTypeInternal;
extern ListCatheterResponseDefaultTypeInternal _ListCatheterResponse_default_instance_;
class RecordCatheterRequest;
class RecordCatheterRequestDefaultTypeInternal;
extern RecordCatheterRequestDefaultTypeInternal _RecordCatheterRequest_default_instance_;
class RecordCatheterResponse;
class RecordCatheterResponseDefaultTypeInternal;
extern RecordCatheterResponseDefaultTypeInternal _RecordCatheterResponse_default_instance_;
}  // namespace protos
}  // namespace platform
}  // namespace pyrus
}  // namespace com
}  // namespace github
namespace google {
namespace protobuf {
template<> ::github::com::pyrus::platform::protos::AckReceivedCatheterRequest* Arena::CreateMaybeMessage<::github::com::pyrus::platform::protos::AckReceivedCatheterRequest>(Arena*);
template<> ::github::com::pyrus::platform::protos::AckReceivedCatheterResponse* Arena::CreateMaybeMessage<::github::com::pyrus::platform::protos::AckReceivedCatheterResponse>(Arena*);
template<> ::github::com::pyrus::platform::protos::ListCatheterRequest* Arena::CreateMaybeMessage<::github::com::pyrus::platform::protos::ListCatheterRequest>(Arena*);
template<> ::github::com::pyrus::platform::protos::ListCatheterResponse* Arena::CreateMaybeMessage<::github::com::pyrus::platform::protos::ListCatheterResponse>(Arena*);
template<> ::github::com::pyrus::platform::protos::RecordCatheterRequest* Arena::CreateMaybeMessage<::github::com::pyrus::platform::protos::RecordCatheterRequest>(Arena*);
template<> ::github::com::pyrus::platform::protos::RecordCatheterResponse* Arena::CreateMaybeMessage<::github::com::pyrus::platform::protos::RecordCatheterResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace github {
namespace com {
namespace pyrus {
namespace platform {
namespace protos {

// ===================================================================

class RecordCatheterRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:github.com.pyrus.platform.protos.RecordCatheterRequest) */ {
 public:
  RecordCatheterRequest();
  virtual ~RecordCatheterRequest();

  RecordCatheterRequest(const RecordCatheterRequest& from);

  inline RecordCatheterRequest& operator=(const RecordCatheterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RecordCatheterRequest(RecordCatheterRequest&& from) noexcept
    : RecordCatheterRequest() {
    *this = ::std::move(from);
  }

  inline RecordCatheterRequest& operator=(RecordCatheterRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RecordCatheterRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecordCatheterRequest* internal_default_instance() {
    return reinterpret_cast<const RecordCatheterRequest*>(
               &_RecordCatheterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(RecordCatheterRequest* other);
  friend void swap(RecordCatheterRequest& a, RecordCatheterRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RecordCatheterRequest* New() const final {
    return CreateMaybeMessage<RecordCatheterRequest>(nullptr);
  }

  RecordCatheterRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RecordCatheterRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RecordCatheterRequest& from);
  void MergeFrom(const RecordCatheterRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecordCatheterRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string latencyUUID = 3;
  void clear_latencyuuid();
  static const int kLatencyUUIDFieldNumber = 3;
  const ::std::string& latencyuuid() const;
  void set_latencyuuid(const ::std::string& value);
  #if LANG_CXX11
  void set_latencyuuid(::std::string&& value);
  #endif
  void set_latencyuuid(const char* value);
  void set_latencyuuid(const char* value, size_t size);
  ::std::string* mutable_latencyuuid();
  ::std::string* release_latencyuuid();
  void set_allocated_latencyuuid(::std::string* latencyuuid);

  // .github.com.pyrus.platform.protos.CatheterData data = 1;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::github::com::pyrus::platform::protos::CatheterData& data() const;
  ::github::com::pyrus::platform::protos::CatheterData* release_data();
  ::github::com::pyrus::platform::protos::CatheterData* mutable_data();
  void set_allocated_data(::github::com::pyrus::platform::protos::CatheterData* data);

  // .google.protobuf.Timestamp created = 2;
  bool has_created() const;
  void clear_created();
  static const int kCreatedFieldNumber = 2;
  const ::google::protobuf::Timestamp& created() const;
  ::google::protobuf::Timestamp* release_created();
  ::google::protobuf::Timestamp* mutable_created();
  void set_allocated_created(::google::protobuf::Timestamp* created);

  // @@protoc_insertion_point(class_scope:github.com.pyrus.platform.protos.RecordCatheterRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr latencyuuid_;
  ::github::com::pyrus::platform::protos::CatheterData* data_;
  ::google::protobuf::Timestamp* created_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_catheter_5frecording_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RecordCatheterResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:github.com.pyrus.platform.protos.RecordCatheterResponse) */ {
 public:
  RecordCatheterResponse();
  virtual ~RecordCatheterResponse();

  RecordCatheterResponse(const RecordCatheterResponse& from);

  inline RecordCatheterResponse& operator=(const RecordCatheterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RecordCatheterResponse(RecordCatheterResponse&& from) noexcept
    : RecordCatheterResponse() {
    *this = ::std::move(from);
  }

  inline RecordCatheterResponse& operator=(RecordCatheterResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RecordCatheterResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecordCatheterResponse* internal_default_instance() {
    return reinterpret_cast<const RecordCatheterResponse*>(
               &_RecordCatheterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RecordCatheterResponse* other);
  friend void swap(RecordCatheterResponse& a, RecordCatheterResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RecordCatheterResponse* New() const final {
    return CreateMaybeMessage<RecordCatheterResponse>(nullptr);
  }

  RecordCatheterResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RecordCatheterResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RecordCatheterResponse& from);
  void MergeFrom(const RecordCatheterResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecordCatheterResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:github.com.pyrus.platform.protos.RecordCatheterResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_catheter_5frecording_5fservice_2eproto;
};
// -------------------------------------------------------------------

class AckReceivedCatheterRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:github.com.pyrus.platform.protos.AckReceivedCatheterRequest) */ {
 public:
  AckReceivedCatheterRequest();
  virtual ~AckReceivedCatheterRequest();

  AckReceivedCatheterRequest(const AckReceivedCatheterRequest& from);

  inline AckReceivedCatheterRequest& operator=(const AckReceivedCatheterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AckReceivedCatheterRequest(AckReceivedCatheterRequest&& from) noexcept
    : AckReceivedCatheterRequest() {
    *this = ::std::move(from);
  }

  inline AckReceivedCatheterRequest& operator=(AckReceivedCatheterRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const AckReceivedCatheterRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AckReceivedCatheterRequest* internal_default_instance() {
    return reinterpret_cast<const AckReceivedCatheterRequest*>(
               &_AckReceivedCatheterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(AckReceivedCatheterRequest* other);
  friend void swap(AckReceivedCatheterRequest& a, AckReceivedCatheterRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AckReceivedCatheterRequest* New() const final {
    return CreateMaybeMessage<AckReceivedCatheterRequest>(nullptr);
  }

  AckReceivedCatheterRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AckReceivedCatheterRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AckReceivedCatheterRequest& from);
  void MergeFrom(const AckReceivedCatheterRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AckReceivedCatheterRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string latencyUUID = 1;
  void clear_latencyuuid();
  static const int kLatencyUUIDFieldNumber = 1;
  const ::std::string& latencyuuid() const;
  void set_latencyuuid(const ::std::string& value);
  #if LANG_CXX11
  void set_latencyuuid(::std::string&& value);
  #endif
  void set_latencyuuid(const char* value);
  void set_latencyuuid(const char* value, size_t size);
  ::std::string* mutable_latencyuuid();
  ::std::string* release_latencyuuid();
  void set_allocated_latencyuuid(::std::string* latencyuuid);

  // .google.protobuf.Timestamp acked = 2;
  bool has_acked() const;
  void clear_acked();
  static const int kAckedFieldNumber = 2;
  const ::google::protobuf::Timestamp& acked() const;
  ::google::protobuf::Timestamp* release_acked();
  ::google::protobuf::Timestamp* mutable_acked();
  void set_allocated_acked(::google::protobuf::Timestamp* acked);

  // @@protoc_insertion_point(class_scope:github.com.pyrus.platform.protos.AckReceivedCatheterRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr latencyuuid_;
  ::google::protobuf::Timestamp* acked_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_catheter_5frecording_5fservice_2eproto;
};
// -------------------------------------------------------------------

class AckReceivedCatheterResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:github.com.pyrus.platform.protos.AckReceivedCatheterResponse) */ {
 public:
  AckReceivedCatheterResponse();
  virtual ~AckReceivedCatheterResponse();

  AckReceivedCatheterResponse(const AckReceivedCatheterResponse& from);

  inline AckReceivedCatheterResponse& operator=(const AckReceivedCatheterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AckReceivedCatheterResponse(AckReceivedCatheterResponse&& from) noexcept
    : AckReceivedCatheterResponse() {
    *this = ::std::move(from);
  }

  inline AckReceivedCatheterResponse& operator=(AckReceivedCatheterResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const AckReceivedCatheterResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AckReceivedCatheterResponse* internal_default_instance() {
    return reinterpret_cast<const AckReceivedCatheterResponse*>(
               &_AckReceivedCatheterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(AckReceivedCatheterResponse* other);
  friend void swap(AckReceivedCatheterResponse& a, AckReceivedCatheterResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AckReceivedCatheterResponse* New() const final {
    return CreateMaybeMessage<AckReceivedCatheterResponse>(nullptr);
  }

  AckReceivedCatheterResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AckReceivedCatheterResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AckReceivedCatheterResponse& from);
  void MergeFrom(const AckReceivedCatheterResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AckReceivedCatheterResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:github.com.pyrus.platform.protos.AckReceivedCatheterResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_catheter_5frecording_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ListCatheterRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:github.com.pyrus.platform.protos.ListCatheterRequest) */ {
 public:
  ListCatheterRequest();
  virtual ~ListCatheterRequest();

  ListCatheterRequest(const ListCatheterRequest& from);

  inline ListCatheterRequest& operator=(const ListCatheterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListCatheterRequest(ListCatheterRequest&& from) noexcept
    : ListCatheterRequest() {
    *this = ::std::move(from);
  }

  inline ListCatheterRequest& operator=(ListCatheterRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ListCatheterRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListCatheterRequest* internal_default_instance() {
    return reinterpret_cast<const ListCatheterRequest*>(
               &_ListCatheterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ListCatheterRequest* other);
  friend void swap(ListCatheterRequest& a, ListCatheterRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListCatheterRequest* New() const final {
    return CreateMaybeMessage<ListCatheterRequest>(nullptr);
  }

  ListCatheterRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListCatheterRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListCatheterRequest& from);
  void MergeFrom(const ListCatheterRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListCatheterRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 sessionID = 1;
  void clear_sessionid();
  static const int kSessionIDFieldNumber = 1;
  ::google::protobuf::uint64 sessionid() const;
  void set_sessionid(::google::protobuf::uint64 value);

  // uint64 deviceID = 2;
  void clear_deviceid();
  static const int kDeviceIDFieldNumber = 2;
  ::google::protobuf::uint64 deviceid() const;
  void set_deviceid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:github.com.pyrus.platform.protos.ListCatheterRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 sessionid_;
  ::google::protobuf::uint64 deviceid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_catheter_5frecording_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ListCatheterResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:github.com.pyrus.platform.protos.ListCatheterResponse) */ {
 public:
  ListCatheterResponse();
  virtual ~ListCatheterResponse();

  ListCatheterResponse(const ListCatheterResponse& from);

  inline ListCatheterResponse& operator=(const ListCatheterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListCatheterResponse(ListCatheterResponse&& from) noexcept
    : ListCatheterResponse() {
    *this = ::std::move(from);
  }

  inline ListCatheterResponse& operator=(ListCatheterResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ListCatheterResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListCatheterResponse* internal_default_instance() {
    return reinterpret_cast<const ListCatheterResponse*>(
               &_ListCatheterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ListCatheterResponse* other);
  friend void swap(ListCatheterResponse& a, ListCatheterResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListCatheterResponse* New() const final {
    return CreateMaybeMessage<ListCatheterResponse>(nullptr);
  }

  ListCatheterResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListCatheterResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListCatheterResponse& from);
  void MergeFrom(const ListCatheterResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListCatheterResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .github.com.pyrus.platform.protos.CatheterData data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::github::com::pyrus::platform::protos::CatheterData& data() const;
  ::github::com::pyrus::platform::protos::CatheterData* release_data();
  ::github::com::pyrus::platform::protos::CatheterData* mutable_data();
  void set_allocated_data(::github::com::pyrus::platform::protos::CatheterData* data);

  // .google.protobuf.Timestamp created = 3;
  bool has_created() const;
  void clear_created();
  static const int kCreatedFieldNumber = 3;
  const ::google::protobuf::Timestamp& created() const;
  ::google::protobuf::Timestamp* release_created();
  ::google::protobuf::Timestamp* mutable_created();
  void set_allocated_created(::google::protobuf::Timestamp* created);

  // .google.protobuf.Timestamp acked = 4;
  bool has_acked() const;
  void clear_acked();
  static const int kAckedFieldNumber = 4;
  const ::google::protobuf::Timestamp& acked() const;
  ::google::protobuf::Timestamp* release_acked();
  ::google::protobuf::Timestamp* mutable_acked();
  void set_allocated_acked(::google::protobuf::Timestamp* acked);

  // uint64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // float latency = 5;
  void clear_latency();
  static const int kLatencyFieldNumber = 5;
  float latency() const;
  void set_latency(float value);

  // @@protoc_insertion_point(class_scope:github.com.pyrus.platform.protos.ListCatheterResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::github::com::pyrus::platform::protos::CatheterData* data_;
  ::google::protobuf::Timestamp* created_;
  ::google::protobuf::Timestamp* acked_;
  ::google::protobuf::uint64 id_;
  float latency_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_catheter_5frecording_5fservice_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RecordCatheterRequest

// .github.com.pyrus.platform.protos.CatheterData data = 1;
inline bool RecordCatheterRequest::has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline const ::github::com::pyrus::platform::protos::CatheterData& RecordCatheterRequest::data() const {
  const ::github::com::pyrus::platform::protos::CatheterData* p = data_;
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.RecordCatheterRequest.data)
  return p != nullptr ? *p : *reinterpret_cast<const ::github::com::pyrus::platform::protos::CatheterData*>(
      &::github::com::pyrus::platform::protos::_CatheterData_default_instance_);
}
inline ::github::com::pyrus::platform::protos::CatheterData* RecordCatheterRequest::release_data() {
  // @@protoc_insertion_point(field_release:github.com.pyrus.platform.protos.RecordCatheterRequest.data)
  
  ::github::com::pyrus::platform::protos::CatheterData* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::github::com::pyrus::platform::protos::CatheterData* RecordCatheterRequest::mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::github::com::pyrus::platform::protos::CatheterData>(GetArenaNoVirtual());
    data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:github.com.pyrus.platform.protos.RecordCatheterRequest.data)
  return data_;
}
inline void RecordCatheterRequest::set_allocated_data(::github::com::pyrus::platform::protos::CatheterData* data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(data_);
  }
  if (data) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:github.com.pyrus.platform.protos.RecordCatheterRequest.data)
}

// .google.protobuf.Timestamp created = 2;
inline bool RecordCatheterRequest::has_created() const {
  return this != internal_default_instance() && created_ != nullptr;
}
inline const ::google::protobuf::Timestamp& RecordCatheterRequest::created() const {
  const ::google::protobuf::Timestamp* p = created_;
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.RecordCatheterRequest.created)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* RecordCatheterRequest::release_created() {
  // @@protoc_insertion_point(field_release:github.com.pyrus.platform.protos.RecordCatheterRequest.created)
  
  ::google::protobuf::Timestamp* temp = created_;
  created_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* RecordCatheterRequest::mutable_created() {
  
  if (created_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    created_ = p;
  }
  // @@protoc_insertion_point(field_mutable:github.com.pyrus.platform.protos.RecordCatheterRequest.created)
  return created_;
}
inline void RecordCatheterRequest::set_allocated_created(::google::protobuf::Timestamp* created) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(created_);
  }
  if (created) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(created)->GetArena();
    if (message_arena != submessage_arena) {
      created = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, created, submessage_arena);
    }
    
  } else {
    
  }
  created_ = created;
  // @@protoc_insertion_point(field_set_allocated:github.com.pyrus.platform.protos.RecordCatheterRequest.created)
}

// string latencyUUID = 3;
inline void RecordCatheterRequest::clear_latencyuuid() {
  latencyuuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RecordCatheterRequest::latencyuuid() const {
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.RecordCatheterRequest.latencyUUID)
  return latencyuuid_.GetNoArena();
}
inline void RecordCatheterRequest::set_latencyuuid(const ::std::string& value) {
  
  latencyuuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:github.com.pyrus.platform.protos.RecordCatheterRequest.latencyUUID)
}
#if LANG_CXX11
inline void RecordCatheterRequest::set_latencyuuid(::std::string&& value) {
  
  latencyuuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:github.com.pyrus.platform.protos.RecordCatheterRequest.latencyUUID)
}
#endif
inline void RecordCatheterRequest::set_latencyuuid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  latencyuuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:github.com.pyrus.platform.protos.RecordCatheterRequest.latencyUUID)
}
inline void RecordCatheterRequest::set_latencyuuid(const char* value, size_t size) {
  
  latencyuuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:github.com.pyrus.platform.protos.RecordCatheterRequest.latencyUUID)
}
inline ::std::string* RecordCatheterRequest::mutable_latencyuuid() {
  
  // @@protoc_insertion_point(field_mutable:github.com.pyrus.platform.protos.RecordCatheterRequest.latencyUUID)
  return latencyuuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RecordCatheterRequest::release_latencyuuid() {
  // @@protoc_insertion_point(field_release:github.com.pyrus.platform.protos.RecordCatheterRequest.latencyUUID)
  
  return latencyuuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RecordCatheterRequest::set_allocated_latencyuuid(::std::string* latencyuuid) {
  if (latencyuuid != nullptr) {
    
  } else {
    
  }
  latencyuuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), latencyuuid);
  // @@protoc_insertion_point(field_set_allocated:github.com.pyrus.platform.protos.RecordCatheterRequest.latencyUUID)
}

// -------------------------------------------------------------------

// RecordCatheterResponse

// -------------------------------------------------------------------

// AckReceivedCatheterRequest

// string latencyUUID = 1;
inline void AckReceivedCatheterRequest::clear_latencyuuid() {
  latencyuuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AckReceivedCatheterRequest::latencyuuid() const {
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.AckReceivedCatheterRequest.latencyUUID)
  return latencyuuid_.GetNoArena();
}
inline void AckReceivedCatheterRequest::set_latencyuuid(const ::std::string& value) {
  
  latencyuuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:github.com.pyrus.platform.protos.AckReceivedCatheterRequest.latencyUUID)
}
#if LANG_CXX11
inline void AckReceivedCatheterRequest::set_latencyuuid(::std::string&& value) {
  
  latencyuuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:github.com.pyrus.platform.protos.AckReceivedCatheterRequest.latencyUUID)
}
#endif
inline void AckReceivedCatheterRequest::set_latencyuuid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  latencyuuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:github.com.pyrus.platform.protos.AckReceivedCatheterRequest.latencyUUID)
}
inline void AckReceivedCatheterRequest::set_latencyuuid(const char* value, size_t size) {
  
  latencyuuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:github.com.pyrus.platform.protos.AckReceivedCatheterRequest.latencyUUID)
}
inline ::std::string* AckReceivedCatheterRequest::mutable_latencyuuid() {
  
  // @@protoc_insertion_point(field_mutable:github.com.pyrus.platform.protos.AckReceivedCatheterRequest.latencyUUID)
  return latencyuuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AckReceivedCatheterRequest::release_latencyuuid() {
  // @@protoc_insertion_point(field_release:github.com.pyrus.platform.protos.AckReceivedCatheterRequest.latencyUUID)
  
  return latencyuuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AckReceivedCatheterRequest::set_allocated_latencyuuid(::std::string* latencyuuid) {
  if (latencyuuid != nullptr) {
    
  } else {
    
  }
  latencyuuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), latencyuuid);
  // @@protoc_insertion_point(field_set_allocated:github.com.pyrus.platform.protos.AckReceivedCatheterRequest.latencyUUID)
}

// .google.protobuf.Timestamp acked = 2;
inline bool AckReceivedCatheterRequest::has_acked() const {
  return this != internal_default_instance() && acked_ != nullptr;
}
inline const ::google::protobuf::Timestamp& AckReceivedCatheterRequest::acked() const {
  const ::google::protobuf::Timestamp* p = acked_;
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.AckReceivedCatheterRequest.acked)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* AckReceivedCatheterRequest::release_acked() {
  // @@protoc_insertion_point(field_release:github.com.pyrus.platform.protos.AckReceivedCatheterRequest.acked)
  
  ::google::protobuf::Timestamp* temp = acked_;
  acked_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* AckReceivedCatheterRequest::mutable_acked() {
  
  if (acked_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    acked_ = p;
  }
  // @@protoc_insertion_point(field_mutable:github.com.pyrus.platform.protos.AckReceivedCatheterRequest.acked)
  return acked_;
}
inline void AckReceivedCatheterRequest::set_allocated_acked(::google::protobuf::Timestamp* acked) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(acked_);
  }
  if (acked) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(acked)->GetArena();
    if (message_arena != submessage_arena) {
      acked = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, acked, submessage_arena);
    }
    
  } else {
    
  }
  acked_ = acked;
  // @@protoc_insertion_point(field_set_allocated:github.com.pyrus.platform.protos.AckReceivedCatheterRequest.acked)
}

// -------------------------------------------------------------------

// AckReceivedCatheterResponse

// -------------------------------------------------------------------

// ListCatheterRequest

// uint64 sessionID = 1;
inline void ListCatheterRequest::clear_sessionid() {
  sessionid_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ListCatheterRequest::sessionid() const {
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.ListCatheterRequest.sessionID)
  return sessionid_;
}
inline void ListCatheterRequest::set_sessionid(::google::protobuf::uint64 value) {
  
  sessionid_ = value;
  // @@protoc_insertion_point(field_set:github.com.pyrus.platform.protos.ListCatheterRequest.sessionID)
}

// uint64 deviceID = 2;
inline void ListCatheterRequest::clear_deviceid() {
  deviceid_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ListCatheterRequest::deviceid() const {
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.ListCatheterRequest.deviceID)
  return deviceid_;
}
inline void ListCatheterRequest::set_deviceid(::google::protobuf::uint64 value) {
  
  deviceid_ = value;
  // @@protoc_insertion_point(field_set:github.com.pyrus.platform.protos.ListCatheterRequest.deviceID)
}

// -------------------------------------------------------------------

// ListCatheterResponse

// uint64 id = 1;
inline void ListCatheterResponse::clear_id() {
  id_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ListCatheterResponse::id() const {
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.ListCatheterResponse.id)
  return id_;
}
inline void ListCatheterResponse::set_id(::google::protobuf::uint64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:github.com.pyrus.platform.protos.ListCatheterResponse.id)
}

// .github.com.pyrus.platform.protos.CatheterData data = 2;
inline bool ListCatheterResponse::has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline const ::github::com::pyrus::platform::protos::CatheterData& ListCatheterResponse::data() const {
  const ::github::com::pyrus::platform::protos::CatheterData* p = data_;
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.ListCatheterResponse.data)
  return p != nullptr ? *p : *reinterpret_cast<const ::github::com::pyrus::platform::protos::CatheterData*>(
      &::github::com::pyrus::platform::protos::_CatheterData_default_instance_);
}
inline ::github::com::pyrus::platform::protos::CatheterData* ListCatheterResponse::release_data() {
  // @@protoc_insertion_point(field_release:github.com.pyrus.platform.protos.ListCatheterResponse.data)
  
  ::github::com::pyrus::platform::protos::CatheterData* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::github::com::pyrus::platform::protos::CatheterData* ListCatheterResponse::mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::github::com::pyrus::platform::protos::CatheterData>(GetArenaNoVirtual());
    data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:github.com.pyrus.platform.protos.ListCatheterResponse.data)
  return data_;
}
inline void ListCatheterResponse::set_allocated_data(::github::com::pyrus::platform::protos::CatheterData* data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(data_);
  }
  if (data) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:github.com.pyrus.platform.protos.ListCatheterResponse.data)
}

// .google.protobuf.Timestamp created = 3;
inline bool ListCatheterResponse::has_created() const {
  return this != internal_default_instance() && created_ != nullptr;
}
inline const ::google::protobuf::Timestamp& ListCatheterResponse::created() const {
  const ::google::protobuf::Timestamp* p = created_;
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.ListCatheterResponse.created)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* ListCatheterResponse::release_created() {
  // @@protoc_insertion_point(field_release:github.com.pyrus.platform.protos.ListCatheterResponse.created)
  
  ::google::protobuf::Timestamp* temp = created_;
  created_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* ListCatheterResponse::mutable_created() {
  
  if (created_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    created_ = p;
  }
  // @@protoc_insertion_point(field_mutable:github.com.pyrus.platform.protos.ListCatheterResponse.created)
  return created_;
}
inline void ListCatheterResponse::set_allocated_created(::google::protobuf::Timestamp* created) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(created_);
  }
  if (created) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(created)->GetArena();
    if (message_arena != submessage_arena) {
      created = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, created, submessage_arena);
    }
    
  } else {
    
  }
  created_ = created;
  // @@protoc_insertion_point(field_set_allocated:github.com.pyrus.platform.protos.ListCatheterResponse.created)
}

// .google.protobuf.Timestamp acked = 4;
inline bool ListCatheterResponse::has_acked() const {
  return this != internal_default_instance() && acked_ != nullptr;
}
inline const ::google::protobuf::Timestamp& ListCatheterResponse::acked() const {
  const ::google::protobuf::Timestamp* p = acked_;
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.ListCatheterResponse.acked)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* ListCatheterResponse::release_acked() {
  // @@protoc_insertion_point(field_release:github.com.pyrus.platform.protos.ListCatheterResponse.acked)
  
  ::google::protobuf::Timestamp* temp = acked_;
  acked_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* ListCatheterResponse::mutable_acked() {
  
  if (acked_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    acked_ = p;
  }
  // @@protoc_insertion_point(field_mutable:github.com.pyrus.platform.protos.ListCatheterResponse.acked)
  return acked_;
}
inline void ListCatheterResponse::set_allocated_acked(::google::protobuf::Timestamp* acked) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(acked_);
  }
  if (acked) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(acked)->GetArena();
    if (message_arena != submessage_arena) {
      acked = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, acked, submessage_arena);
    }
    
  } else {
    
  }
  acked_ = acked;
  // @@protoc_insertion_point(field_set_allocated:github.com.pyrus.platform.protos.ListCatheterResponse.acked)
}

// float latency = 5;
inline void ListCatheterResponse::clear_latency() {
  latency_ = 0;
}
inline float ListCatheterResponse::latency() const {
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.ListCatheterResponse.latency)
  return latency_;
}
inline void ListCatheterResponse::set_latency(float value) {
  
  latency_ = value;
  // @@protoc_insertion_point(field_set:github.com.pyrus.platform.protos.ListCatheterResponse.latency)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace platform
}  // namespace pyrus
}  // namespace com
}  // namespace github

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_catheter_5frecording_5fservice_2eproto

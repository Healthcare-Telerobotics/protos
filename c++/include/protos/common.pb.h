// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common.proto

#ifndef PROTOBUF_INCLUDED_common_2eproto
#define PROTOBUF_INCLUDED_common_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/struct.pb.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_common_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_common_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_common_2eproto();
namespace github {
namespace com {
namespace pyrus {
namespace platform {
namespace protos {
class CatheterCoordinates;
class CatheterCoordinatesDefaultTypeInternal;
extern CatheterCoordinatesDefaultTypeInternal _CatheterCoordinates_default_instance_;
class CatheterData;
class CatheterDataDefaultTypeInternal;
extern CatheterDataDefaultTypeInternal _CatheterData_default_instance_;
class Coordinates;
class CoordinatesDefaultTypeInternal;
extern CoordinatesDefaultTypeInternal _Coordinates_default_instance_;
class Device;
class DeviceDefaultTypeInternal;
extern DeviceDefaultTypeInternal _Device_default_instance_;
class DeviceInfo;
class DeviceInfoDefaultTypeInternal;
extern DeviceInfoDefaultTypeInternal _DeviceInfo_default_instance_;
class ElectricalSignalData;
class ElectricalSignalDataDefaultTypeInternal;
extern ElectricalSignalDataDefaultTypeInternal _ElectricalSignalData_default_instance_;
class Frame;
class FrameDefaultTypeInternal;
extern FrameDefaultTypeInternal _Frame_default_instance_;
class NullableRobotControllerData;
class NullableRobotControllerDataDefaultTypeInternal;
extern NullableRobotControllerDataDefaultTypeInternal _NullableRobotControllerData_default_instance_;
class Quaternion;
class QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class RobotControllerData;
class RobotControllerDataDefaultTypeInternal;
extern RobotControllerDataDefaultTypeInternal _RobotControllerData_default_instance_;
}  // namespace protos
}  // namespace platform
}  // namespace pyrus
}  // namespace com
}  // namespace github
namespace google {
namespace protobuf {
template<> ::github::com::pyrus::platform::protos::CatheterCoordinates* Arena::CreateMaybeMessage<::github::com::pyrus::platform::protos::CatheterCoordinates>(Arena*);
template<> ::github::com::pyrus::platform::protos::CatheterData* Arena::CreateMaybeMessage<::github::com::pyrus::platform::protos::CatheterData>(Arena*);
template<> ::github::com::pyrus::platform::protos::Coordinates* Arena::CreateMaybeMessage<::github::com::pyrus::platform::protos::Coordinates>(Arena*);
template<> ::github::com::pyrus::platform::protos::Device* Arena::CreateMaybeMessage<::github::com::pyrus::platform::protos::Device>(Arena*);
template<> ::github::com::pyrus::platform::protos::DeviceInfo* Arena::CreateMaybeMessage<::github::com::pyrus::platform::protos::DeviceInfo>(Arena*);
template<> ::github::com::pyrus::platform::protos::ElectricalSignalData* Arena::CreateMaybeMessage<::github::com::pyrus::platform::protos::ElectricalSignalData>(Arena*);
template<> ::github::com::pyrus::platform::protos::Frame* Arena::CreateMaybeMessage<::github::com::pyrus::platform::protos::Frame>(Arena*);
template<> ::github::com::pyrus::platform::protos::NullableRobotControllerData* Arena::CreateMaybeMessage<::github::com::pyrus::platform::protos::NullableRobotControllerData>(Arena*);
template<> ::github::com::pyrus::platform::protos::Quaternion* Arena::CreateMaybeMessage<::github::com::pyrus::platform::protos::Quaternion>(Arena*);
template<> ::github::com::pyrus::platform::protos::RobotControllerData* Arena::CreateMaybeMessage<::github::com::pyrus::platform::protos::RobotControllerData>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace github {
namespace com {
namespace pyrus {
namespace platform {
namespace protos {

enum DeviceType {
  Robot = 0,
  Controller = 1,
  Catheter = 2,
  Headset = 3,
  ElectricalSignalGenerator = 4,
  DeviceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  DeviceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool DeviceType_IsValid(int value);
const DeviceType DeviceType_MIN = Robot;
const DeviceType DeviceType_MAX = ElectricalSignalGenerator;
const int DeviceType_ARRAYSIZE = DeviceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DeviceType_descriptor();
inline const ::std::string& DeviceType_Name(DeviceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DeviceType_descriptor(), value);
}
inline bool DeviceType_Parse(
    const ::std::string& name, DeviceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DeviceType>(
    DeviceType_descriptor(), name, value);
}
enum DataType {
  RobotState = 0,
  RobotControls = 1,
  CatheterSensorCoordinates = 2,
  ElectricalSignals = 3,
  DataType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  DataType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool DataType_IsValid(int value);
const DataType DataType_MIN = RobotState;
const DataType DataType_MAX = ElectricalSignals;
const int DataType_ARRAYSIZE = DataType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DataType_descriptor();
inline const ::std::string& DataType_Name(DataType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DataType_descriptor(), value);
}
inline bool DataType_Parse(
    const ::std::string& name, DataType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DataType>(
    DataType_descriptor(), name, value);
}
// ===================================================================

class Device final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:github.com.pyrus.platform.protos.Device) */ {
 public:
  Device();
  virtual ~Device();

  Device(const Device& from);

  inline Device& operator=(const Device& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Device(Device&& from) noexcept
    : Device() {
    *this = ::std::move(from);
  }

  inline Device& operator=(Device&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Device& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Device* internal_default_instance() {
    return reinterpret_cast<const Device*>(
               &_Device_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Device* other);
  friend void swap(Device& a, Device& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Device* New() const final {
    return CreateMaybeMessage<Device>(nullptr);
  }

  Device* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Device>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Device& from);
  void MergeFrom(const Device& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Device* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .github.com.pyrus.platform.protos.DeviceInfo info = 2;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 2;
  const ::github::com::pyrus::platform::protos::DeviceInfo& info() const;
  ::github::com::pyrus::platform::protos::DeviceInfo* release_info();
  ::github::com::pyrus::platform::protos::DeviceInfo* mutable_info();
  void set_allocated_info(::github::com::pyrus::platform::protos::DeviceInfo* info);

  // uint64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:github.com.pyrus.platform.protos.Device)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::github::com::pyrus::platform::protos::DeviceInfo* info_;
  ::google::protobuf::uint64 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class DeviceInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:github.com.pyrus.platform.protos.DeviceInfo) */ {
 public:
  DeviceInfo();
  virtual ~DeviceInfo();

  DeviceInfo(const DeviceInfo& from);

  inline DeviceInfo& operator=(const DeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeviceInfo(DeviceInfo&& from) noexcept
    : DeviceInfo() {
    *this = ::std::move(from);
  }

  inline DeviceInfo& operator=(DeviceInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DeviceInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeviceInfo* internal_default_instance() {
    return reinterpret_cast<const DeviceInfo*>(
               &_DeviceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(DeviceInfo* other);
  friend void swap(DeviceInfo& a, DeviceInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeviceInfo* New() const final {
    return CreateMaybeMessage<DeviceInfo>(nullptr);
  }

  DeviceInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeviceInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeviceInfo& from);
  void MergeFrom(const DeviceInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .github.com.pyrus.platform.protos.DataType produces = 5;
  int produces_size() const;
  void clear_produces();
  static const int kProducesFieldNumber = 5;
  ::github::com::pyrus::platform::protos::DataType produces(int index) const;
  void set_produces(int index, ::github::com::pyrus::platform::protos::DataType value);
  void add_produces(::github::com::pyrus::platform::protos::DataType value);
  const ::google::protobuf::RepeatedField<int>& produces() const;
  ::google::protobuf::RepeatedField<int>* mutable_produces();

  // repeated .github.com.pyrus.platform.protos.DataType consumes = 6;
  int consumes_size() const;
  void clear_consumes();
  static const int kConsumesFieldNumber = 6;
  ::github::com::pyrus::platform::protos::DataType consumes(int index) const;
  void set_consumes(int index, ::github::com::pyrus::platform::protos::DataType value);
  void add_consumes(::github::com::pyrus::platform::protos::DataType value);
  const ::google::protobuf::RepeatedField<int>& consumes() const;
  ::google::protobuf::RepeatedField<int>* mutable_consumes();

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string ip = 3;
  void clear_ip();
  static const int kIpFieldNumber = 3;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // .github.com.pyrus.platform.protos.DeviceType type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::github::com::pyrus::platform::protos::DeviceType type() const;
  void set_type(::github::com::pyrus::platform::protos::DeviceType value);

  // uint32 port = 4;
  void clear_port();
  static const int kPortFieldNumber = 4;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:github.com.pyrus.platform.protos.DeviceInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField<int> produces_;
  mutable std::atomic<int> _produces_cached_byte_size_;
  ::google::protobuf::RepeatedField<int> consumes_;
  mutable std::atomic<int> _consumes_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  int type_;
  ::google::protobuf::uint32 port_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Coordinates final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:github.com.pyrus.platform.protos.Coordinates) */ {
 public:
  Coordinates();
  virtual ~Coordinates();

  Coordinates(const Coordinates& from);

  inline Coordinates& operator=(const Coordinates& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Coordinates(Coordinates&& from) noexcept
    : Coordinates() {
    *this = ::std::move(from);
  }

  inline Coordinates& operator=(Coordinates&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Coordinates& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Coordinates* internal_default_instance() {
    return reinterpret_cast<const Coordinates*>(
               &_Coordinates_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Coordinates* other);
  friend void swap(Coordinates& a, Coordinates& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Coordinates* New() const final {
    return CreateMaybeMessage<Coordinates>(nullptr);
  }

  Coordinates* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Coordinates>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Coordinates& from);
  void MergeFrom(const Coordinates& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Coordinates* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // float z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:github.com.pyrus.platform.protos.Coordinates)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float z_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Quaternion final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:github.com.pyrus.platform.protos.Quaternion) */ {
 public:
  Quaternion();
  virtual ~Quaternion();

  Quaternion(const Quaternion& from);

  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Quaternion(Quaternion&& from) noexcept
    : Quaternion() {
    *this = ::std::move(from);
  }

  inline Quaternion& operator=(Quaternion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Quaternion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Quaternion* internal_default_instance() {
    return reinterpret_cast<const Quaternion*>(
               &_Quaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Quaternion* other);
  friend void swap(Quaternion& a, Quaternion& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Quaternion* New() const final {
    return CreateMaybeMessage<Quaternion>(nullptr);
  }

  Quaternion* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Quaternion>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Quaternion& from);
  void MergeFrom(const Quaternion& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Quaternion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float w = 1;
  void clear_w();
  static const int kWFieldNumber = 1;
  float w() const;
  void set_w(float value);

  // float x = 2;
  void clear_x();
  static const int kXFieldNumber = 2;
  float x() const;
  void set_x(float value);

  // float y = 3;
  void clear_y();
  static const int kYFieldNumber = 3;
  float y() const;
  void set_y(float value);

  // float z = 4;
  void clear_z();
  static const int kZFieldNumber = 4;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:github.com.pyrus.platform.protos.Quaternion)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float w_;
  float x_;
  float y_;
  float z_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class CatheterCoordinates final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:github.com.pyrus.platform.protos.CatheterCoordinates) */ {
 public:
  CatheterCoordinates();
  virtual ~CatheterCoordinates();

  CatheterCoordinates(const CatheterCoordinates& from);

  inline CatheterCoordinates& operator=(const CatheterCoordinates& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CatheterCoordinates(CatheterCoordinates&& from) noexcept
    : CatheterCoordinates() {
    *this = ::std::move(from);
  }

  inline CatheterCoordinates& operator=(CatheterCoordinates&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CatheterCoordinates& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CatheterCoordinates* internal_default_instance() {
    return reinterpret_cast<const CatheterCoordinates*>(
               &_CatheterCoordinates_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(CatheterCoordinates* other);
  friend void swap(CatheterCoordinates& a, CatheterCoordinates& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CatheterCoordinates* New() const final {
    return CreateMaybeMessage<CatheterCoordinates>(nullptr);
  }

  CatheterCoordinates* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CatheterCoordinates>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CatheterCoordinates& from);
  void MergeFrom(const CatheterCoordinates& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CatheterCoordinates* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .github.com.pyrus.platform.protos.Coordinates position = 1;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  const ::github::com::pyrus::platform::protos::Coordinates& position() const;
  ::github::com::pyrus::platform::protos::Coordinates* release_position();
  ::github::com::pyrus::platform::protos::Coordinates* mutable_position();
  void set_allocated_position(::github::com::pyrus::platform::protos::Coordinates* position);

  // .github.com.pyrus.platform.protos.Quaternion rotation = 2;
  bool has_rotation() const;
  void clear_rotation();
  static const int kRotationFieldNumber = 2;
  const ::github::com::pyrus::platform::protos::Quaternion& rotation() const;
  ::github::com::pyrus::platform::protos::Quaternion* release_rotation();
  ::github::com::pyrus::platform::protos::Quaternion* mutable_rotation();
  void set_allocated_rotation(::github::com::pyrus::platform::protos::Quaternion* rotation);

  // @@protoc_insertion_point(class_scope:github.com.pyrus.platform.protos.CatheterCoordinates)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::github::com::pyrus::platform::protos::Coordinates* position_;
  ::github::com::pyrus::platform::protos::Quaternion* rotation_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class CatheterData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:github.com.pyrus.platform.protos.CatheterData) */ {
 public:
  CatheterData();
  virtual ~CatheterData();

  CatheterData(const CatheterData& from);

  inline CatheterData& operator=(const CatheterData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CatheterData(CatheterData&& from) noexcept
    : CatheterData() {
    *this = ::std::move(from);
  }

  inline CatheterData& operator=(CatheterData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CatheterData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CatheterData* internal_default_instance() {
    return reinterpret_cast<const CatheterData*>(
               &_CatheterData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(CatheterData* other);
  friend void swap(CatheterData& a, CatheterData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CatheterData* New() const final {
    return CreateMaybeMessage<CatheterData>(nullptr);
  }

  CatheterData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CatheterData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CatheterData& from);
  void MergeFrom(const CatheterData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CatheterData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .github.com.pyrus.platform.protos.CatheterCoordinates coordinates = 2;
  bool has_coordinates() const;
  void clear_coordinates();
  static const int kCoordinatesFieldNumber = 2;
  const ::github::com::pyrus::platform::protos::CatheterCoordinates& coordinates() const;
  ::github::com::pyrus::platform::protos::CatheterCoordinates* release_coordinates();
  ::github::com::pyrus::platform::protos::CatheterCoordinates* mutable_coordinates();
  void set_allocated_coordinates(::github::com::pyrus::platform::protos::CatheterCoordinates* coordinates);

  // uint32 sensorId = 1;
  void clear_sensorid();
  static const int kSensorIdFieldNumber = 1;
  ::google::protobuf::uint32 sensorid() const;
  void set_sensorid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:github.com.pyrus.platform.protos.CatheterData)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::github::com::pyrus::platform::protos::CatheterCoordinates* coordinates_;
  ::google::protobuf::uint32 sensorid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class RobotControllerData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:github.com.pyrus.platform.protos.RobotControllerData) */ {
 public:
  RobotControllerData();
  virtual ~RobotControllerData();

  RobotControllerData(const RobotControllerData& from);

  inline RobotControllerData& operator=(const RobotControllerData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RobotControllerData(RobotControllerData&& from) noexcept
    : RobotControllerData() {
    *this = ::std::move(from);
  }

  inline RobotControllerData& operator=(RobotControllerData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RobotControllerData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotControllerData* internal_default_instance() {
    return reinterpret_cast<const RobotControllerData*>(
               &_RobotControllerData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(RobotControllerData* other);
  friend void swap(RobotControllerData& a, RobotControllerData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RobotControllerData* New() const final {
    return CreateMaybeMessage<RobotControllerData>(nullptr);
  }

  RobotControllerData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RobotControllerData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RobotControllerData& from);
  void MergeFrom(const RobotControllerData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotControllerData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float movementVelocity = 1;
  void clear_movementvelocity();
  static const int kMovementVelocityFieldNumber = 1;
  float movementvelocity() const;
  void set_movementvelocity(float value);

  // float rotationVelocity = 2;
  void clear_rotationvelocity();
  static const int kRotationVelocityFieldNumber = 2;
  float rotationvelocity() const;
  void set_rotationvelocity(float value);

  // float deflectionVelocity = 3;
  void clear_deflectionvelocity();
  static const int kDeflectionVelocityFieldNumber = 3;
  float deflectionvelocity() const;
  void set_deflectionvelocity(float value);

  // @@protoc_insertion_point(class_scope:github.com.pyrus.platform.protos.RobotControllerData)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float movementvelocity_;
  float rotationvelocity_;
  float deflectionvelocity_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class NullableRobotControllerData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:github.com.pyrus.platform.protos.NullableRobotControllerData) */ {
 public:
  NullableRobotControllerData();
  virtual ~NullableRobotControllerData();

  NullableRobotControllerData(const NullableRobotControllerData& from);

  inline NullableRobotControllerData& operator=(const NullableRobotControllerData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NullableRobotControllerData(NullableRobotControllerData&& from) noexcept
    : NullableRobotControllerData() {
    *this = ::std::move(from);
  }

  inline NullableRobotControllerData& operator=(NullableRobotControllerData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const NullableRobotControllerData& default_instance();

  enum KindCase {
    kNull = 1,
    kData = 2,
    KIND_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NullableRobotControllerData* internal_default_instance() {
    return reinterpret_cast<const NullableRobotControllerData*>(
               &_NullableRobotControllerData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(NullableRobotControllerData* other);
  friend void swap(NullableRobotControllerData& a, NullableRobotControllerData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NullableRobotControllerData* New() const final {
    return CreateMaybeMessage<NullableRobotControllerData>(nullptr);
  }

  NullableRobotControllerData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NullableRobotControllerData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NullableRobotControllerData& from);
  void MergeFrom(const NullableRobotControllerData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NullableRobotControllerData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.NullValue null = 1;
  private:
  bool has_null() const;
  public:
  void clear_null();
  static const int kNullFieldNumber = 1;
  ::google::protobuf::NullValue null() const;
  void set_null(::google::protobuf::NullValue value);

  // .github.com.pyrus.platform.protos.RobotControllerData data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::github::com::pyrus::platform::protos::RobotControllerData& data() const;
  ::github::com::pyrus::platform::protos::RobotControllerData* release_data();
  ::github::com::pyrus::platform::protos::RobotControllerData* mutable_data();
  void set_allocated_data(::github::com::pyrus::platform::protos::RobotControllerData* data);

  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:github.com.pyrus.platform.protos.NullableRobotControllerData)
 private:
  class HasBitSetters;
  void set_has_null();
  void set_has_data();

  inline bool has_kind() const;
  inline void clear_has_kind();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union KindUnion {
    KindUnion() {}
    int null_;
    ::github::com::pyrus::platform::protos::RobotControllerData* data_;
  } kind_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class ElectricalSignalData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:github.com.pyrus.platform.protos.ElectricalSignalData) */ {
 public:
  ElectricalSignalData();
  virtual ~ElectricalSignalData();

  ElectricalSignalData(const ElectricalSignalData& from);

  inline ElectricalSignalData& operator=(const ElectricalSignalData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ElectricalSignalData(ElectricalSignalData&& from) noexcept
    : ElectricalSignalData() {
    *this = ::std::move(from);
  }

  inline ElectricalSignalData& operator=(ElectricalSignalData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ElectricalSignalData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ElectricalSignalData* internal_default_instance() {
    return reinterpret_cast<const ElectricalSignalData*>(
               &_ElectricalSignalData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ElectricalSignalData* other);
  friend void swap(ElectricalSignalData& a, ElectricalSignalData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ElectricalSignalData* New() const final {
    return CreateMaybeMessage<ElectricalSignalData>(nullptr);
  }

  ElectricalSignalData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ElectricalSignalData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ElectricalSignalData& from);
  void MergeFrom(const ElectricalSignalData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ElectricalSignalData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.Timestamp created = 4;
  bool has_created() const;
  void clear_created();
  static const int kCreatedFieldNumber = 4;
  const ::google::protobuf::Timestamp& created() const;
  ::google::protobuf::Timestamp* release_created();
  ::google::protobuf::Timestamp* mutable_created();
  void set_allocated_created(::google::protobuf::Timestamp* created);

  // uint32 signalId = 1;
  void clear_signalid();
  static const int kSignalIdFieldNumber = 1;
  ::google::protobuf::uint32 signalid() const;
  void set_signalid(::google::protobuf::uint32 value);

  // float value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  float value() const;
  void set_value(float value);

  // @@protoc_insertion_point(class_scope:github.com.pyrus.platform.protos.ElectricalSignalData)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Timestamp* created_;
  ::google::protobuf::uint32 signalid_;
  float value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Frame final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:github.com.pyrus.platform.protos.Frame) */ {
 public:
  Frame();
  virtual ~Frame();

  Frame(const Frame& from);

  inline Frame& operator=(const Frame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Frame(Frame&& from) noexcept
    : Frame() {
    *this = ::std::move(from);
  }

  inline Frame& operator=(Frame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Frame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Frame* internal_default_instance() {
    return reinterpret_cast<const Frame*>(
               &_Frame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Frame* other);
  friend void swap(Frame& a, Frame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Frame* New() const final {
    return CreateMaybeMessage<Frame>(nullptr);
  }

  Frame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Frame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Frame& from);
  void MergeFrom(const Frame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Frame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .github.com.pyrus.platform.protos.CatheterData catheterData = 1;
  int catheterdata_size() const;
  void clear_catheterdata();
  static const int kCatheterDataFieldNumber = 1;
  ::github::com::pyrus::platform::protos::CatheterData* mutable_catheterdata(int index);
  ::google::protobuf::RepeatedPtrField< ::github::com::pyrus::platform::protos::CatheterData >*
      mutable_catheterdata();
  const ::github::com::pyrus::platform::protos::CatheterData& catheterdata(int index) const;
  ::github::com::pyrus::platform::protos::CatheterData* add_catheterdata();
  const ::google::protobuf::RepeatedPtrField< ::github::com::pyrus::platform::protos::CatheterData >&
      catheterdata() const;

  // repeated .github.com.pyrus.platform.protos.ElectricalSignalData electricalSignals = 3;
  int electricalsignals_size() const;
  void clear_electricalsignals();
  static const int kElectricalSignalsFieldNumber = 3;
  ::github::com::pyrus::platform::protos::ElectricalSignalData* mutable_electricalsignals(int index);
  ::google::protobuf::RepeatedPtrField< ::github::com::pyrus::platform::protos::ElectricalSignalData >*
      mutable_electricalsignals();
  const ::github::com::pyrus::platform::protos::ElectricalSignalData& electricalsignals(int index) const;
  ::github::com::pyrus::platform::protos::ElectricalSignalData* add_electricalsignals();
  const ::google::protobuf::RepeatedPtrField< ::github::com::pyrus::platform::protos::ElectricalSignalData >&
      electricalsignals() const;

  // .github.com.pyrus.platform.protos.NullableRobotControllerData nullableRobotControllerData = 2;
  bool has_nullablerobotcontrollerdata() const;
  void clear_nullablerobotcontrollerdata();
  static const int kNullableRobotControllerDataFieldNumber = 2;
  const ::github::com::pyrus::platform::protos::NullableRobotControllerData& nullablerobotcontrollerdata() const;
  ::github::com::pyrus::platform::protos::NullableRobotControllerData* release_nullablerobotcontrollerdata();
  ::github::com::pyrus::platform::protos::NullableRobotControllerData* mutable_nullablerobotcontrollerdata();
  void set_allocated_nullablerobotcontrollerdata(::github::com::pyrus::platform::protos::NullableRobotControllerData* nullablerobotcontrollerdata);

  // .google.protobuf.Timestamp created = 4;
  bool has_created() const;
  void clear_created();
  static const int kCreatedFieldNumber = 4;
  const ::google::protobuf::Timestamp& created() const;
  ::google::protobuf::Timestamp* release_created();
  ::google::protobuf::Timestamp* mutable_created();
  void set_allocated_created(::google::protobuf::Timestamp* created);

  // @@protoc_insertion_point(class_scope:github.com.pyrus.platform.protos.Frame)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::github::com::pyrus::platform::protos::CatheterData > catheterdata_;
  ::google::protobuf::RepeatedPtrField< ::github::com::pyrus::platform::protos::ElectricalSignalData > electricalsignals_;
  ::github::com::pyrus::platform::protos::NullableRobotControllerData* nullablerobotcontrollerdata_;
  ::google::protobuf::Timestamp* created_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Device

// uint64 id = 1;
inline void Device::clear_id() {
  id_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Device::id() const {
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.Device.id)
  return id_;
}
inline void Device::set_id(::google::protobuf::uint64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:github.com.pyrus.platform.protos.Device.id)
}

// .github.com.pyrus.platform.protos.DeviceInfo info = 2;
inline bool Device::has_info() const {
  return this != internal_default_instance() && info_ != nullptr;
}
inline void Device::clear_info() {
  if (GetArenaNoVirtual() == nullptr && info_ != nullptr) {
    delete info_;
  }
  info_ = nullptr;
}
inline const ::github::com::pyrus::platform::protos::DeviceInfo& Device::info() const {
  const ::github::com::pyrus::platform::protos::DeviceInfo* p = info_;
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.Device.info)
  return p != nullptr ? *p : *reinterpret_cast<const ::github::com::pyrus::platform::protos::DeviceInfo*>(
      &::github::com::pyrus::platform::protos::_DeviceInfo_default_instance_);
}
inline ::github::com::pyrus::platform::protos::DeviceInfo* Device::release_info() {
  // @@protoc_insertion_point(field_release:github.com.pyrus.platform.protos.Device.info)
  
  ::github::com::pyrus::platform::protos::DeviceInfo* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::github::com::pyrus::platform::protos::DeviceInfo* Device::mutable_info() {
  
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::github::com::pyrus::platform::protos::DeviceInfo>(GetArenaNoVirtual());
    info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:github.com.pyrus.platform.protos.Device.info)
  return info_;
}
inline void Device::set_allocated_info(::github::com::pyrus::platform::protos::DeviceInfo* info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete info_;
  }
  if (info) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:github.com.pyrus.platform.protos.Device.info)
}

// -------------------------------------------------------------------

// DeviceInfo

// string name = 1;
inline void DeviceInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeviceInfo::name() const {
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.DeviceInfo.name)
  return name_.GetNoArena();
}
inline void DeviceInfo::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:github.com.pyrus.platform.protos.DeviceInfo.name)
}
#if LANG_CXX11
inline void DeviceInfo::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:github.com.pyrus.platform.protos.DeviceInfo.name)
}
#endif
inline void DeviceInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:github.com.pyrus.platform.protos.DeviceInfo.name)
}
inline void DeviceInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:github.com.pyrus.platform.protos.DeviceInfo.name)
}
inline ::std::string* DeviceInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:github.com.pyrus.platform.protos.DeviceInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceInfo::release_name() {
  // @@protoc_insertion_point(field_release:github.com.pyrus.platform.protos.DeviceInfo.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfo::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:github.com.pyrus.platform.protos.DeviceInfo.name)
}

// .github.com.pyrus.platform.protos.DeviceType type = 2;
inline void DeviceInfo::clear_type() {
  type_ = 0;
}
inline ::github::com::pyrus::platform::protos::DeviceType DeviceInfo::type() const {
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.DeviceInfo.type)
  return static_cast< ::github::com::pyrus::platform::protos::DeviceType >(type_);
}
inline void DeviceInfo::set_type(::github::com::pyrus::platform::protos::DeviceType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:github.com.pyrus.platform.protos.DeviceInfo.type)
}

// string ip = 3;
inline void DeviceInfo::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeviceInfo::ip() const {
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.DeviceInfo.ip)
  return ip_.GetNoArena();
}
inline void DeviceInfo::set_ip(const ::std::string& value) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:github.com.pyrus.platform.protos.DeviceInfo.ip)
}
#if LANG_CXX11
inline void DeviceInfo::set_ip(::std::string&& value) {
  
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:github.com.pyrus.platform.protos.DeviceInfo.ip)
}
#endif
inline void DeviceInfo::set_ip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:github.com.pyrus.platform.protos.DeviceInfo.ip)
}
inline void DeviceInfo::set_ip(const char* value, size_t size) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:github.com.pyrus.platform.protos.DeviceInfo.ip)
}
inline ::std::string* DeviceInfo::mutable_ip() {
  
  // @@protoc_insertion_point(field_mutable:github.com.pyrus.platform.protos.DeviceInfo.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceInfo::release_ip() {
  // @@protoc_insertion_point(field_release:github.com.pyrus.platform.protos.DeviceInfo.ip)
  
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfo::set_allocated_ip(::std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:github.com.pyrus.platform.protos.DeviceInfo.ip)
}

// uint32 port = 4;
inline void DeviceInfo::clear_port() {
  port_ = 0u;
}
inline ::google::protobuf::uint32 DeviceInfo::port() const {
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.DeviceInfo.port)
  return port_;
}
inline void DeviceInfo::set_port(::google::protobuf::uint32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:github.com.pyrus.platform.protos.DeviceInfo.port)
}

// repeated .github.com.pyrus.platform.protos.DataType produces = 5;
inline int DeviceInfo::produces_size() const {
  return produces_.size();
}
inline void DeviceInfo::clear_produces() {
  produces_.Clear();
}
inline ::github::com::pyrus::platform::protos::DataType DeviceInfo::produces(int index) const {
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.DeviceInfo.produces)
  return static_cast< ::github::com::pyrus::platform::protos::DataType >(produces_.Get(index));
}
inline void DeviceInfo::set_produces(int index, ::github::com::pyrus::platform::protos::DataType value) {
  produces_.Set(index, value);
  // @@protoc_insertion_point(field_set:github.com.pyrus.platform.protos.DeviceInfo.produces)
}
inline void DeviceInfo::add_produces(::github::com::pyrus::platform::protos::DataType value) {
  produces_.Add(value);
  // @@protoc_insertion_point(field_add:github.com.pyrus.platform.protos.DeviceInfo.produces)
}
inline const ::google::protobuf::RepeatedField<int>&
DeviceInfo::produces() const {
  // @@protoc_insertion_point(field_list:github.com.pyrus.platform.protos.DeviceInfo.produces)
  return produces_;
}
inline ::google::protobuf::RepeatedField<int>*
DeviceInfo::mutable_produces() {
  // @@protoc_insertion_point(field_mutable_list:github.com.pyrus.platform.protos.DeviceInfo.produces)
  return &produces_;
}

// repeated .github.com.pyrus.platform.protos.DataType consumes = 6;
inline int DeviceInfo::consumes_size() const {
  return consumes_.size();
}
inline void DeviceInfo::clear_consumes() {
  consumes_.Clear();
}
inline ::github::com::pyrus::platform::protos::DataType DeviceInfo::consumes(int index) const {
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.DeviceInfo.consumes)
  return static_cast< ::github::com::pyrus::platform::protos::DataType >(consumes_.Get(index));
}
inline void DeviceInfo::set_consumes(int index, ::github::com::pyrus::platform::protos::DataType value) {
  consumes_.Set(index, value);
  // @@protoc_insertion_point(field_set:github.com.pyrus.platform.protos.DeviceInfo.consumes)
}
inline void DeviceInfo::add_consumes(::github::com::pyrus::platform::protos::DataType value) {
  consumes_.Add(value);
  // @@protoc_insertion_point(field_add:github.com.pyrus.platform.protos.DeviceInfo.consumes)
}
inline const ::google::protobuf::RepeatedField<int>&
DeviceInfo::consumes() const {
  // @@protoc_insertion_point(field_list:github.com.pyrus.platform.protos.DeviceInfo.consumes)
  return consumes_;
}
inline ::google::protobuf::RepeatedField<int>*
DeviceInfo::mutable_consumes() {
  // @@protoc_insertion_point(field_mutable_list:github.com.pyrus.platform.protos.DeviceInfo.consumes)
  return &consumes_;
}

// -------------------------------------------------------------------

// Coordinates

// float x = 1;
inline void Coordinates::clear_x() {
  x_ = 0;
}
inline float Coordinates::x() const {
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.Coordinates.x)
  return x_;
}
inline void Coordinates::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:github.com.pyrus.platform.protos.Coordinates.x)
}

// float y = 2;
inline void Coordinates::clear_y() {
  y_ = 0;
}
inline float Coordinates::y() const {
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.Coordinates.y)
  return y_;
}
inline void Coordinates::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:github.com.pyrus.platform.protos.Coordinates.y)
}

// float z = 3;
inline void Coordinates::clear_z() {
  z_ = 0;
}
inline float Coordinates::z() const {
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.Coordinates.z)
  return z_;
}
inline void Coordinates::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:github.com.pyrus.platform.protos.Coordinates.z)
}

// -------------------------------------------------------------------

// Quaternion

// float w = 1;
inline void Quaternion::clear_w() {
  w_ = 0;
}
inline float Quaternion::w() const {
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.Quaternion.w)
  return w_;
}
inline void Quaternion::set_w(float value) {
  
  w_ = value;
  // @@protoc_insertion_point(field_set:github.com.pyrus.platform.protos.Quaternion.w)
}

// float x = 2;
inline void Quaternion::clear_x() {
  x_ = 0;
}
inline float Quaternion::x() const {
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.Quaternion.x)
  return x_;
}
inline void Quaternion::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:github.com.pyrus.platform.protos.Quaternion.x)
}

// float y = 3;
inline void Quaternion::clear_y() {
  y_ = 0;
}
inline float Quaternion::y() const {
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.Quaternion.y)
  return y_;
}
inline void Quaternion::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:github.com.pyrus.platform.protos.Quaternion.y)
}

// float z = 4;
inline void Quaternion::clear_z() {
  z_ = 0;
}
inline float Quaternion::z() const {
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.Quaternion.z)
  return z_;
}
inline void Quaternion::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:github.com.pyrus.platform.protos.Quaternion.z)
}

// -------------------------------------------------------------------

// CatheterCoordinates

// .github.com.pyrus.platform.protos.Coordinates position = 1;
inline bool CatheterCoordinates::has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline void CatheterCoordinates::clear_position() {
  if (GetArenaNoVirtual() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::github::com::pyrus::platform::protos::Coordinates& CatheterCoordinates::position() const {
  const ::github::com::pyrus::platform::protos::Coordinates* p = position_;
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.CatheterCoordinates.position)
  return p != nullptr ? *p : *reinterpret_cast<const ::github::com::pyrus::platform::protos::Coordinates*>(
      &::github::com::pyrus::platform::protos::_Coordinates_default_instance_);
}
inline ::github::com::pyrus::platform::protos::Coordinates* CatheterCoordinates::release_position() {
  // @@protoc_insertion_point(field_release:github.com.pyrus.platform.protos.CatheterCoordinates.position)
  
  ::github::com::pyrus::platform::protos::Coordinates* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::github::com::pyrus::platform::protos::Coordinates* CatheterCoordinates::mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::github::com::pyrus::platform::protos::Coordinates>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:github.com.pyrus.platform.protos.CatheterCoordinates.position)
  return position_;
}
inline void CatheterCoordinates::set_allocated_position(::github::com::pyrus::platform::protos::Coordinates* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:github.com.pyrus.platform.protos.CatheterCoordinates.position)
}

// .github.com.pyrus.platform.protos.Quaternion rotation = 2;
inline bool CatheterCoordinates::has_rotation() const {
  return this != internal_default_instance() && rotation_ != nullptr;
}
inline void CatheterCoordinates::clear_rotation() {
  if (GetArenaNoVirtual() == nullptr && rotation_ != nullptr) {
    delete rotation_;
  }
  rotation_ = nullptr;
}
inline const ::github::com::pyrus::platform::protos::Quaternion& CatheterCoordinates::rotation() const {
  const ::github::com::pyrus::platform::protos::Quaternion* p = rotation_;
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.CatheterCoordinates.rotation)
  return p != nullptr ? *p : *reinterpret_cast<const ::github::com::pyrus::platform::protos::Quaternion*>(
      &::github::com::pyrus::platform::protos::_Quaternion_default_instance_);
}
inline ::github::com::pyrus::platform::protos::Quaternion* CatheterCoordinates::release_rotation() {
  // @@protoc_insertion_point(field_release:github.com.pyrus.platform.protos.CatheterCoordinates.rotation)
  
  ::github::com::pyrus::platform::protos::Quaternion* temp = rotation_;
  rotation_ = nullptr;
  return temp;
}
inline ::github::com::pyrus::platform::protos::Quaternion* CatheterCoordinates::mutable_rotation() {
  
  if (rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::github::com::pyrus::platform::protos::Quaternion>(GetArenaNoVirtual());
    rotation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:github.com.pyrus.platform.protos.CatheterCoordinates.rotation)
  return rotation_;
}
inline void CatheterCoordinates::set_allocated_rotation(::github::com::pyrus::platform::protos::Quaternion* rotation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete rotation_;
  }
  if (rotation) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      rotation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    
  } else {
    
  }
  rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:github.com.pyrus.platform.protos.CatheterCoordinates.rotation)
}

// -------------------------------------------------------------------

// CatheterData

// uint32 sensorId = 1;
inline void CatheterData::clear_sensorid() {
  sensorid_ = 0u;
}
inline ::google::protobuf::uint32 CatheterData::sensorid() const {
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.CatheterData.sensorId)
  return sensorid_;
}
inline void CatheterData::set_sensorid(::google::protobuf::uint32 value) {
  
  sensorid_ = value;
  // @@protoc_insertion_point(field_set:github.com.pyrus.platform.protos.CatheterData.sensorId)
}

// .github.com.pyrus.platform.protos.CatheterCoordinates coordinates = 2;
inline bool CatheterData::has_coordinates() const {
  return this != internal_default_instance() && coordinates_ != nullptr;
}
inline void CatheterData::clear_coordinates() {
  if (GetArenaNoVirtual() == nullptr && coordinates_ != nullptr) {
    delete coordinates_;
  }
  coordinates_ = nullptr;
}
inline const ::github::com::pyrus::platform::protos::CatheterCoordinates& CatheterData::coordinates() const {
  const ::github::com::pyrus::platform::protos::CatheterCoordinates* p = coordinates_;
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.CatheterData.coordinates)
  return p != nullptr ? *p : *reinterpret_cast<const ::github::com::pyrus::platform::protos::CatheterCoordinates*>(
      &::github::com::pyrus::platform::protos::_CatheterCoordinates_default_instance_);
}
inline ::github::com::pyrus::platform::protos::CatheterCoordinates* CatheterData::release_coordinates() {
  // @@protoc_insertion_point(field_release:github.com.pyrus.platform.protos.CatheterData.coordinates)
  
  ::github::com::pyrus::platform::protos::CatheterCoordinates* temp = coordinates_;
  coordinates_ = nullptr;
  return temp;
}
inline ::github::com::pyrus::platform::protos::CatheterCoordinates* CatheterData::mutable_coordinates() {
  
  if (coordinates_ == nullptr) {
    auto* p = CreateMaybeMessage<::github::com::pyrus::platform::protos::CatheterCoordinates>(GetArenaNoVirtual());
    coordinates_ = p;
  }
  // @@protoc_insertion_point(field_mutable:github.com.pyrus.platform.protos.CatheterData.coordinates)
  return coordinates_;
}
inline void CatheterData::set_allocated_coordinates(::github::com::pyrus::platform::protos::CatheterCoordinates* coordinates) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete coordinates_;
  }
  if (coordinates) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      coordinates = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, coordinates, submessage_arena);
    }
    
  } else {
    
  }
  coordinates_ = coordinates;
  // @@protoc_insertion_point(field_set_allocated:github.com.pyrus.platform.protos.CatheterData.coordinates)
}

// -------------------------------------------------------------------

// RobotControllerData

// float movementVelocity = 1;
inline void RobotControllerData::clear_movementvelocity() {
  movementvelocity_ = 0;
}
inline float RobotControllerData::movementvelocity() const {
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.RobotControllerData.movementVelocity)
  return movementvelocity_;
}
inline void RobotControllerData::set_movementvelocity(float value) {
  
  movementvelocity_ = value;
  // @@protoc_insertion_point(field_set:github.com.pyrus.platform.protos.RobotControllerData.movementVelocity)
}

// float rotationVelocity = 2;
inline void RobotControllerData::clear_rotationvelocity() {
  rotationvelocity_ = 0;
}
inline float RobotControllerData::rotationvelocity() const {
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.RobotControllerData.rotationVelocity)
  return rotationvelocity_;
}
inline void RobotControllerData::set_rotationvelocity(float value) {
  
  rotationvelocity_ = value;
  // @@protoc_insertion_point(field_set:github.com.pyrus.platform.protos.RobotControllerData.rotationVelocity)
}

// float deflectionVelocity = 3;
inline void RobotControllerData::clear_deflectionvelocity() {
  deflectionvelocity_ = 0;
}
inline float RobotControllerData::deflectionvelocity() const {
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.RobotControllerData.deflectionVelocity)
  return deflectionvelocity_;
}
inline void RobotControllerData::set_deflectionvelocity(float value) {
  
  deflectionvelocity_ = value;
  // @@protoc_insertion_point(field_set:github.com.pyrus.platform.protos.RobotControllerData.deflectionVelocity)
}

// -------------------------------------------------------------------

// NullableRobotControllerData

// .google.protobuf.NullValue null = 1;
inline bool NullableRobotControllerData::has_null() const {
  return kind_case() == kNull;
}
inline void NullableRobotControllerData::set_has_null() {
  _oneof_case_[0] = kNull;
}
inline void NullableRobotControllerData::clear_null() {
  if (has_null()) {
    kind_.null_ = 0;
    clear_has_kind();
  }
}
inline ::google::protobuf::NullValue NullableRobotControllerData::null() const {
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.NullableRobotControllerData.null)
  if (has_null()) {
    return static_cast< ::google::protobuf::NullValue >(kind_.null_);
  }
  return static_cast< ::google::protobuf::NullValue >(0);
}
inline void NullableRobotControllerData::set_null(::google::protobuf::NullValue value) {
  if (!has_null()) {
    clear_kind();
    set_has_null();
  }
  kind_.null_ = value;
  // @@protoc_insertion_point(field_set:github.com.pyrus.platform.protos.NullableRobotControllerData.null)
}

// .github.com.pyrus.platform.protos.RobotControllerData data = 2;
inline bool NullableRobotControllerData::has_data() const {
  return kind_case() == kData;
}
inline void NullableRobotControllerData::set_has_data() {
  _oneof_case_[0] = kData;
}
inline void NullableRobotControllerData::clear_data() {
  if (has_data()) {
    delete kind_.data_;
    clear_has_kind();
  }
}
inline ::github::com::pyrus::platform::protos::RobotControllerData* NullableRobotControllerData::release_data() {
  // @@protoc_insertion_point(field_release:github.com.pyrus.platform.protos.NullableRobotControllerData.data)
  if (has_data()) {
    clear_has_kind();
      ::github::com::pyrus::platform::protos::RobotControllerData* temp = kind_.data_;
    kind_.data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::github::com::pyrus::platform::protos::RobotControllerData& NullableRobotControllerData::data() const {
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.NullableRobotControllerData.data)
  return has_data()
      ? *kind_.data_
      : *reinterpret_cast< ::github::com::pyrus::platform::protos::RobotControllerData*>(&::github::com::pyrus::platform::protos::_RobotControllerData_default_instance_);
}
inline ::github::com::pyrus::platform::protos::RobotControllerData* NullableRobotControllerData::mutable_data() {
  if (!has_data()) {
    clear_kind();
    set_has_data();
    kind_.data_ = CreateMaybeMessage< ::github::com::pyrus::platform::protos::RobotControllerData >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:github.com.pyrus.platform.protos.NullableRobotControllerData.data)
  return kind_.data_;
}

inline bool NullableRobotControllerData::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void NullableRobotControllerData::clear_has_kind() {
  _oneof_case_[0] = KIND_NOT_SET;
}
inline NullableRobotControllerData::KindCase NullableRobotControllerData::kind_case() const {
  return NullableRobotControllerData::KindCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ElectricalSignalData

// uint32 signalId = 1;
inline void ElectricalSignalData::clear_signalid() {
  signalid_ = 0u;
}
inline ::google::protobuf::uint32 ElectricalSignalData::signalid() const {
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.ElectricalSignalData.signalId)
  return signalid_;
}
inline void ElectricalSignalData::set_signalid(::google::protobuf::uint32 value) {
  
  signalid_ = value;
  // @@protoc_insertion_point(field_set:github.com.pyrus.platform.protos.ElectricalSignalData.signalId)
}

// float value = 2;
inline void ElectricalSignalData::clear_value() {
  value_ = 0;
}
inline float ElectricalSignalData::value() const {
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.ElectricalSignalData.value)
  return value_;
}
inline void ElectricalSignalData::set_value(float value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:github.com.pyrus.platform.protos.ElectricalSignalData.value)
}

// .google.protobuf.Timestamp created = 4;
inline bool ElectricalSignalData::has_created() const {
  return this != internal_default_instance() && created_ != nullptr;
}
inline const ::google::protobuf::Timestamp& ElectricalSignalData::created() const {
  const ::google::protobuf::Timestamp* p = created_;
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.ElectricalSignalData.created)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* ElectricalSignalData::release_created() {
  // @@protoc_insertion_point(field_release:github.com.pyrus.platform.protos.ElectricalSignalData.created)
  
  ::google::protobuf::Timestamp* temp = created_;
  created_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* ElectricalSignalData::mutable_created() {
  
  if (created_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    created_ = p;
  }
  // @@protoc_insertion_point(field_mutable:github.com.pyrus.platform.protos.ElectricalSignalData.created)
  return created_;
}
inline void ElectricalSignalData::set_allocated_created(::google::protobuf::Timestamp* created) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(created_);
  }
  if (created) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(created)->GetArena();
    if (message_arena != submessage_arena) {
      created = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, created, submessage_arena);
    }
    
  } else {
    
  }
  created_ = created;
  // @@protoc_insertion_point(field_set_allocated:github.com.pyrus.platform.protos.ElectricalSignalData.created)
}

// -------------------------------------------------------------------

// Frame

// repeated .github.com.pyrus.platform.protos.CatheterData catheterData = 1;
inline int Frame::catheterdata_size() const {
  return catheterdata_.size();
}
inline void Frame::clear_catheterdata() {
  catheterdata_.Clear();
}
inline ::github::com::pyrus::platform::protos::CatheterData* Frame::mutable_catheterdata(int index) {
  // @@protoc_insertion_point(field_mutable:github.com.pyrus.platform.protos.Frame.catheterData)
  return catheterdata_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::github::com::pyrus::platform::protos::CatheterData >*
Frame::mutable_catheterdata() {
  // @@protoc_insertion_point(field_mutable_list:github.com.pyrus.platform.protos.Frame.catheterData)
  return &catheterdata_;
}
inline const ::github::com::pyrus::platform::protos::CatheterData& Frame::catheterdata(int index) const {
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.Frame.catheterData)
  return catheterdata_.Get(index);
}
inline ::github::com::pyrus::platform::protos::CatheterData* Frame::add_catheterdata() {
  // @@protoc_insertion_point(field_add:github.com.pyrus.platform.protos.Frame.catheterData)
  return catheterdata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::github::com::pyrus::platform::protos::CatheterData >&
Frame::catheterdata() const {
  // @@protoc_insertion_point(field_list:github.com.pyrus.platform.protos.Frame.catheterData)
  return catheterdata_;
}

// .github.com.pyrus.platform.protos.NullableRobotControllerData nullableRobotControllerData = 2;
inline bool Frame::has_nullablerobotcontrollerdata() const {
  return this != internal_default_instance() && nullablerobotcontrollerdata_ != nullptr;
}
inline void Frame::clear_nullablerobotcontrollerdata() {
  if (GetArenaNoVirtual() == nullptr && nullablerobotcontrollerdata_ != nullptr) {
    delete nullablerobotcontrollerdata_;
  }
  nullablerobotcontrollerdata_ = nullptr;
}
inline const ::github::com::pyrus::platform::protos::NullableRobotControllerData& Frame::nullablerobotcontrollerdata() const {
  const ::github::com::pyrus::platform::protos::NullableRobotControllerData* p = nullablerobotcontrollerdata_;
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.Frame.nullableRobotControllerData)
  return p != nullptr ? *p : *reinterpret_cast<const ::github::com::pyrus::platform::protos::NullableRobotControllerData*>(
      &::github::com::pyrus::platform::protos::_NullableRobotControllerData_default_instance_);
}
inline ::github::com::pyrus::platform::protos::NullableRobotControllerData* Frame::release_nullablerobotcontrollerdata() {
  // @@protoc_insertion_point(field_release:github.com.pyrus.platform.protos.Frame.nullableRobotControllerData)
  
  ::github::com::pyrus::platform::protos::NullableRobotControllerData* temp = nullablerobotcontrollerdata_;
  nullablerobotcontrollerdata_ = nullptr;
  return temp;
}
inline ::github::com::pyrus::platform::protos::NullableRobotControllerData* Frame::mutable_nullablerobotcontrollerdata() {
  
  if (nullablerobotcontrollerdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::github::com::pyrus::platform::protos::NullableRobotControllerData>(GetArenaNoVirtual());
    nullablerobotcontrollerdata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:github.com.pyrus.platform.protos.Frame.nullableRobotControllerData)
  return nullablerobotcontrollerdata_;
}
inline void Frame::set_allocated_nullablerobotcontrollerdata(::github::com::pyrus::platform::protos::NullableRobotControllerData* nullablerobotcontrollerdata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete nullablerobotcontrollerdata_;
  }
  if (nullablerobotcontrollerdata) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      nullablerobotcontrollerdata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, nullablerobotcontrollerdata, submessage_arena);
    }
    
  } else {
    
  }
  nullablerobotcontrollerdata_ = nullablerobotcontrollerdata;
  // @@protoc_insertion_point(field_set_allocated:github.com.pyrus.platform.protos.Frame.nullableRobotControllerData)
}

// repeated .github.com.pyrus.platform.protos.ElectricalSignalData electricalSignals = 3;
inline int Frame::electricalsignals_size() const {
  return electricalsignals_.size();
}
inline void Frame::clear_electricalsignals() {
  electricalsignals_.Clear();
}
inline ::github::com::pyrus::platform::protos::ElectricalSignalData* Frame::mutable_electricalsignals(int index) {
  // @@protoc_insertion_point(field_mutable:github.com.pyrus.platform.protos.Frame.electricalSignals)
  return electricalsignals_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::github::com::pyrus::platform::protos::ElectricalSignalData >*
Frame::mutable_electricalsignals() {
  // @@protoc_insertion_point(field_mutable_list:github.com.pyrus.platform.protos.Frame.electricalSignals)
  return &electricalsignals_;
}
inline const ::github::com::pyrus::platform::protos::ElectricalSignalData& Frame::electricalsignals(int index) const {
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.Frame.electricalSignals)
  return electricalsignals_.Get(index);
}
inline ::github::com::pyrus::platform::protos::ElectricalSignalData* Frame::add_electricalsignals() {
  // @@protoc_insertion_point(field_add:github.com.pyrus.platform.protos.Frame.electricalSignals)
  return electricalsignals_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::github::com::pyrus::platform::protos::ElectricalSignalData >&
Frame::electricalsignals() const {
  // @@protoc_insertion_point(field_list:github.com.pyrus.platform.protos.Frame.electricalSignals)
  return electricalsignals_;
}

// .google.protobuf.Timestamp created = 4;
inline bool Frame::has_created() const {
  return this != internal_default_instance() && created_ != nullptr;
}
inline const ::google::protobuf::Timestamp& Frame::created() const {
  const ::google::protobuf::Timestamp* p = created_;
  // @@protoc_insertion_point(field_get:github.com.pyrus.platform.protos.Frame.created)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* Frame::release_created() {
  // @@protoc_insertion_point(field_release:github.com.pyrus.platform.protos.Frame.created)
  
  ::google::protobuf::Timestamp* temp = created_;
  created_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Frame::mutable_created() {
  
  if (created_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    created_ = p;
  }
  // @@protoc_insertion_point(field_mutable:github.com.pyrus.platform.protos.Frame.created)
  return created_;
}
inline void Frame::set_allocated_created(::google::protobuf::Timestamp* created) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(created_);
  }
  if (created) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(created)->GetArena();
    if (message_arena != submessage_arena) {
      created = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, created, submessage_arena);
    }
    
  } else {
    
  }
  created_ = created;
  // @@protoc_insertion_point(field_set_allocated:github.com.pyrus.platform.protos.Frame.created)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace platform
}  // namespace pyrus
}  // namespace com
}  // namespace github

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::github::com::pyrus::platform::protos::DeviceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::github::com::pyrus::platform::protos::DeviceType>() {
  return ::github::com::pyrus::platform::protos::DeviceType_descriptor();
}
template <> struct is_proto_enum< ::github::com::pyrus::platform::protos::DataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::github::com::pyrus::platform::protos::DataType>() {
  return ::github::com::pyrus::platform::protos::DataType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_common_2eproto
